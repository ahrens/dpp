#!/sbin/sh
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T.
# All rights reserved.
#
#
# Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# Copyright (c) 2013 by Delphix. All rights reserved.
#

. /lib/svc/share/smf_include.sh
. /lib/svc/share/net_include.sh

# Make sure that the libraries essential to this stage of booting can be found.
LD_LIBRARY_PATH=/lib; export LD_LIBRARY_PATH

writable_root()
{
	2> /dev/null >> /etc/hosts
	return $?
}

#
# Store the /etc/hosts loopback hostname mapping so that we can update it
# when the hostname is later changed.
#
save_loopback_mapping()
{
	mapping=$1
	/usr/sbin/svccfg -s $SMF_FMRI setprop config/loopback = $mapping || \
	    return 1
	/usr/sbin/svccfg -s $SMF_FMRI refresh
}

mapping_exists()
{
	sed '/^#/d' /etc/hosts | nawk '{$1=$1}1' OFS="\n" | grep '^'"$1"'$' > \
	    /dev/null
	return $?
}

#
# This function returns true if the argument is a partially qualified
# domain name, false otherwise.
#
partially_qualified_domain_name()
{
	echo "$1" | grep -q "\."
	return $?
}

add_loopback_mapping()
{
	new=$1
	loopback_mapping=$2
	if ! mapping_exists $new; then
		tmp_hosts=/tmp/hosts.$$

		sed -e 's/^\(127.0.0.1[ 	]*\)\(*\)*/\1'"$new"' \2/g' \
		    -e 's/^\(::1[ 	]*\)\(*\)*/\1'"$new"' \2/g' \
		    /etc/inet/hosts >$tmp_hosts
		if [[ $? -ne 0 ]]; then
			return 1
		fi

		cp $tmp_hosts /etc/inet/hosts || return 1
		rm -f $tmp_hosts
	fi

	save_loopback_mapping $loopback_mapping
	return $?
}

update_loopback_mapping()
{
	old=$1
	new=$2
	loopback_mapping=$3
	tmp_hosts=/tmp/hosts.$$

	if ! mapping_exists $new; then
		sed -e '/^127.0.0.1/ s/\([ 	]\)'"$old"'\([ 	.]\)/\1'"$new"'\2/g' \
		    -e '/^127.0.0.1/ s/\([ 	]\)'"$old"'$/\1'"$new"'/g' \
		    -e '/^::1/ s/\([ 	]\)'"$old"'\([ 	.]\)/\1'"$new"'\2/g' \
		    -e '/^::1/ s/\([ 	]\)'"$old"'$/\1'"$new"'/g' \
		    /etc/inet/hosts >$tmp_hosts
		if [[ $? -ne 0 ]]; then
			return 1
		fi

		cp $tmp_hosts /etc/inet/hosts || return 1
		rm -f $tmp_hosts
	fi

	save_loopback_mapping $loopback_mapping
	return $?
}

#
# Set the hostname either from the local /etc/nodename file or from the network
# (DHCP or RPC bootparams).  If no hostname was set via any of these methods,
# then set it to "unknown" (it needs to be set to _something_ as expected by
# countless applications).  We then ensure that an /etc/hosts loopback addres
# mapping exists for the hostname, as many applications expect the hostname to
# resolve to a local address.
#
# For non-global zones, fall back to the `uname -n` value provided by the
# kernel if /etc/nodename does not exist, as is expected on an initial boot.
#

smf_netstrategy

case "$_INIT_NET_STRATEGY" in
"dhcp") hostname=$(/sbin/dhcpinfo Hostname) ;;
"rarp") hostname=$(/sbin/hostconfig -h -p bootparams)
	trap 'intr=1' 2 3
	while [[ -z "$hostname" && ! -f /etc/.UNCONFIGURED && -z "$intr" ]]; do
		echo "re-trying host configuration..."
		# Restrict this to IPv4 interfaces.
		/sbin/ifconfig -adD4 auto-revarp up
		hostname=$(/sbin/hostconfig -h -p bootparams)
	done
	trap 2 3 ;;
"none") hostname="$(shcat /etc/nodename 2>/dev/null)"
	if [[ -z "$hostname" ]]; then
		if smf_is_globalzone; then
			hostname=$(/sbin/hostconfig -h -p bootparams)
		else
			hostname=$(/sbin/uname -n)
		fi
	fi ;;
esac

local_override=$(/usr/bin/svcprop -p config/local_override $SMF_FMRI)
if [[ -z "$hostname" || "$local_override" = "true" ]]; then
	hostname="$(shcat /etc/nodename 2>/dev/null)"
	if [[ -z "$hostname" ]]; then
		hostname="unknown"
	fi
fi

/sbin/uname -S $hostname

#
# Create or update the hostname /etc/hosts loopback mapping if the management
# of the mapping is enabled.  We only do this if the root filesystem is
# writable.  The only known case where this service is enabled while root is
# read-only is when booted off of the miniroot during install.  In that case,
# we don't really care if /etc/hosts contains the hostname or not.
#
enable_mapping=$(/usr/bin/svcprop -p config/enable_mapping $SMF_FMRI)
if writable_root && [[ "$enable_mapping" = "true" ]]; then
	oldmapping=$(/usr/bin/svcprop -p config/loopback $SMF_FMRI)
	newmapping="$hostname"
	#
	# sendmail requires a partially qualified domain name (PQDN).
	# Hence, if the hostname is not a PQDN, convert it into one
	# and add it to /etc/inet/hosts. If the hostname changes, we
	# would need to remove the previous PQDN and hence need to
	# process the older hostname as well.
	#
	if ! partially_qualified_domain_name "$newmapping"; then
		newmapping="$hostname\ $hostname.local"
	fi
	if [[ "$oldmapping" != '""' ]]; then
		if ! partially_qualified_domain_name "$oldmapping"; then
			oldmapping="$oldmapping\ $oldmapping.local"
		fi
	fi
	if [[ "$oldmapping" = '""' ]]; then
		#
		# During the first boot after installation, there is no
		# existing /etc/hosts mapping.
		#
		add_loopback_mapping "$newmapping" "$hostname" \
			|| exit $SMF_ERR_FATAL
	elif [[ "$oldmapping" != "$newmapping" ]]; then
		#
		# The hostname has changed since this service was last enabled
		# or refreshed.  We need to update the /etc/hosts mapping.
		#
		update_loopback_mapping "$oldmapping" "$newmapping" "$hostname" \
			|| exit $SMF_ERR_FATAL
	fi
fi

#
# We only print the hostname on the console when the service is started
# (i.e. during boot).  There's no need to pollute the console when the
# service is subsequently refreshed.
#
if [[ "$1" = "start" ]]; then
	echo "Hostname: $(/sbin/uname -n)" > /dev/msglog
fi

# Reset the library path now that we are past the critical stage
unset LD_LIBRARY_PATH

exit $SMF_EXIT_OK
